<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Camera Capture & QR Scan</title>
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        line-height: 1.4;
        color: #1d1d1f;
        background: #f5f5f7;
      }

      body {
        margin: 0;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        max-width: 720px;
        min-height: 100vh;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      h1 {
        margin: 0;
        font-size: 1.6rem;
      }

      p {
        margin: 0;
        font-size: 0.95rem;
      }

      #camera-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      video,
      canvas,
      img {
        width: 100%;
        border-radius: 0.75rem;
        background: #000;
      }

      #video-container {
        position: relative;
        width: 100%;
      }

      video {
        object-fit: cover;
        display: block;
        position: relative;
        z-index: 0;
        width: 100%;
      }

      #qr-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        border-radius: 0.75rem;
        background: transparent;
        z-index: 1;
        opacity: 1;
      }

      #capture-button-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 0;
        gap: 1rem;
      }

      #capture-button-container #capture {
        flex-shrink: 0;
      }

      #capture-button-container #toggle-camera,
      #capture-button-container #toggle-scan {
        flex: 1;
        max-width: 120px;
      }

      #capture {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: 4px solid #fff;
        background: #9e9e9e;
        cursor: pointer;
        padding: 0;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
        position: relative;
        font-size: 0;
        text-indent: -9999px;
        overflow: hidden;
      }

      #capture:enabled {
        background: #9e9e9e;
      }

      #capture:enabled:active,
      #capture:enabled.pressed {
        background: #ff3b30;
        transform: scale(0.95);
        box-shadow: 0 2px 8px rgba(255, 59, 48, 0.4);
      }

      #capture:disabled {
        background: #9e9e9e;
        opacity: 0.5;
        cursor: not-allowed;
      }

      #controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.75rem;
      }

      button {
        cursor: pointer;
        padding: 0.75rem 1.25rem;
        border-radius: 999px;
        border: none;
        font-size: 0.95rem;
        font-weight: 600;
        background: #0a84ff;
        color: #fff;
        box-shadow: 0 6px 16px rgba(10, 132, 255, 0.2);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button:hover,
      button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(10, 132, 255, 0.3);
      }

      button.secondary {
        background: #e5e5ea;
        color: #1d1d1f;
        box-shadow: 0 4px 10px rgba(60, 60, 67, 0.15);
      }

      #photo-output {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      #photo-output a {
        color: #0a84ff;
        text-decoration: none;
        font-weight: 600;
      }

      #qr-result {
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
        background: #f0f9ff;
        border: 1px solid #bae6ff;
        word-break: break-word;
        font-size: 0.95rem;
        display: none;
      }

      #qr-result.error {
        background: #fff1f0;
        border-color: #ffb3ab;
      }

      footer {
        margin-top: auto;
        font-size: 0.85rem;
        color: #6e6e73;
      }
    </style>
  </head>
  <body>
    <section id="camera-area">
      <div id="video-container" style="position: relative; width: 100%;">
        <video id="preview" playsinline muted autoplay></video>
        <canvas id="qr-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;"></canvas>
      </div>

      <div id="capture-button-container">
        <button id="toggle-camera">Start Camera</button>
        <button id="capture" disabled>Capture</button>
        <button id="toggle-scan" class="secondary">Start QR Scan</button>
      </div>

      <div id="qr-result"></div>

      <div id="photo-output">
        <canvas id="photo-canvas" hidden></canvas>
        <img id="photo" alt="Captured photo preview" hidden />
        <a id="download-link" download="photo.jpg" hidden>Download photo</a>
        <div id="photo-actions" style="display: flex; gap: 0.5rem; margin-top: 0.5rem;" hidden>
          <button id="share-photo" class="secondary" hidden>Share Photo</button>
          <button id="save-photo" class="secondary" hidden>Delete photo</button>
        </div>
      </div>
    </section>

    <footer>
      Works offline after first load. Camera and QR scanning require granting
      browser permissions.
    </footer>

    <script>
      const preview = document.getElementById("preview");
      const toggleCameraBtn = document.getElementById("toggle-camera");
      const captureBtn = document.getElementById("capture");
      const scanBtn = document.getElementById("toggle-scan");
      const canvas = document.getElementById("photo-canvas");
      const photo = document.getElementById("photo");
      const downloadLink = document.getElementById("download-link");
      const qrResult = document.getElementById("qr-result");
      const savePhotoBtn = document.getElementById("save-photo");
      const sharePhotoBtn = document.getElementById("share-photo");
      const photoActions = document.getElementById("photo-actions");
      const qrOverlay = document.getElementById("qr-overlay");

      let stream;
      let isScanning = false;
      let scanHandle;
      let barcodeDetector;

      // Dynamic layout adjustment function
      function adjustVideoHeight() {
        const viewportHeight = window.innerHeight;
        const videoContainer = document.getElementById("video-container");
        const captureButtonContainer = document.getElementById("capture-button-container");
        
        // Calculate heights of button containers (measure actual rendered heights)
        const captureButtonHeight = captureButtonContainer ? captureButtonContainer.offsetHeight : 100; // 80px button + padding
        const qrResultHeight = qrResult && qrResult.style.display !== "none" ? qrResult.offsetHeight : 0;
        
        // Calculate available space (viewport - buttons - padding)
        // Body padding (1.5rem top + 1.5rem bottom = 3rem = ~48px) + gaps between camera-area elements (~16px)
        const bodyPadding = 48; // 1.5rem * 2 = 48px
        const gaps = 16; // Gaps between camera-area elements (reduced since controls are now in same row)
        const totalPadding = bodyPadding + gaps;
        const availableHeight = viewportHeight - captureButtonHeight - qrResultHeight - totalPadding;
        
        // Set video height dynamically, but ensure minimum and maximum constraints
        // Minimum 200px, maximum 75% of viewport
        const videoHeight = Math.max(200, Math.min(availableHeight, viewportHeight * 0.75));
        
        if (videoContainer && preview) {
          videoContainer.style.height = `${videoHeight}px`;
          preview.style.height = `${videoHeight}px`;
          preview.style.maxHeight = `${videoHeight}px`;
        }
      }

      // Adjust on load and resize
      window.addEventListener("load", () => {
        setTimeout(adjustVideoHeight, 100); // Small delay to ensure elements are rendered
      });
      window.addEventListener("resize", adjustVideoHeight);

      function checkProtocol() {
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        const href = window.location.href;
        
        // WebView treats file:///android_asset/ as secure context, so allow it
        const isWebView = /Android/i.test(navigator.userAgent) && 
                         (href.includes('android_asset') || href.includes('file:///android_asset'));
        
        if (isWebView) {
          return true; // WebView allows camera access from android_asset
        }
        
        if (protocol === "file:" || protocol === "content:") {
          showError(
            "⚠️ This page is opened from a file. Camera permissions may not work. " +
            "Please host this page on a website (HTTPS) or use a local server. " +
            "You can also try: Chrome Settings → Site Settings → Camera → Reset permissions for this site."
          );
          return false;
        }
        
        if (protocol === "http:" && hostname !== "localhost" && hostname !== "127.0.0.1" && !hostname.startsWith("192.168.") && !hostname.startsWith("10.")) {
          showError(
            "⚠️ Camera access requires HTTPS (secure connection). " +
            "Chrome/Brave block camera access on HTTP websites for security. " +
            "Please host this page on HTTPS or use localhost (http://localhost works)."
          );
          return false;
        }
        
        return true;
      }

      async function initCamera() {
        if (!checkProtocol()) {
          return;
        }
        
        // Check if we're in a secure context (required for camera access)
        if (!window.isSecureContext) {
          showError(
            "⚠️ Camera access requires a secure context (HTTPS or localhost). " +
            "This page is not in a secure context. Please use HTTPS or localhost."
          );
          return;
        }
        
        showMessage("Requesting camera permission...");
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
              width: { ideal: 1920 },
              height: { ideal: 1080 },
            },
            audio: false,
          });
          preview.srcObject = stream;
          await preview.play();

          // Update overlay size when video is ready
          preview.addEventListener("loadedmetadata", () => {
            const overlayRect = qrOverlay.getBoundingClientRect();
            qrOverlay.width = overlayRect.width;
            qrOverlay.height = overlayRect.height;
            // Adjust layout after video loads
            setTimeout(adjustVideoHeight, 100);
          });

          captureBtn.disabled = false;
          scanBtn.disabled = false;
          toggleCameraBtn.textContent = "Stop Camera";

          showMessage("Camera is ready.");
        } catch (error) {
          console.error(error);
          if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
            showError(
              "Camera permission was denied. To fix: Open Chrome menu (⋮) → Settings → Site Settings → Camera → " +
              "Find this page and set to 'Ask' or 'Allow', then reload and try again."
            );
          } else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
            showError(
              "No camera found. Please check that your device has a camera available."
            );
          } else if (error.name === "NotReadableError" || error.name === "TrackStartError") {
            showError(
              "Camera is already in use by another app. Please close other apps using the camera and try again."
            );
          } else {
            showError(
              "Could not access the camera. Please check browser permissions and try again."
            );
          }
        }
      }

      function stopCamera() {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          stream = undefined;
        }
        preview.srcObject = null;
        captureBtn.disabled = true;
        scanBtn.disabled = false; // Keep scan button enabled so it can start camera
        toggleCameraBtn.textContent = "Start Camera";
        stopScanning();
        
        // Clear scanning message if it's just the "Scanning for QR codes..." text
        // But keep actual scanned results (URLs, QR codes with buttons)
        if (qrResult) {
          const hasButtons = qrResult.querySelector("button");
          const hasLinks = qrResult.querySelector("a");
          const isJustScanningMessage = qrResult.textContent.trim() === "Scanning for QR codes...";
          
          // Only clear if it's just the scanning message without any actual results
          if (isJustScanningMessage && !hasButtons && !hasLinks) {
            showMessage(""); // Clear the message
          }
        }
      }

      async function savePhotoAutomatically(dataUrl) {
        // Check if Android interface is available (WebView)
        if (window.AndroidFileSaver) {
          try {
            const result = window.AndroidFileSaver.savePhoto(dataUrl);
            if (result.startsWith("Photo saved:")) {
              showMessage(result);
              return true;
            } else {
              showError(result);
              return false;
            }
          } catch (error) {
            console.error(error);
            showError("Failed to save photo: " + error.message);
            return false;
          }
        }
        
        // Fallback to browser File System Access API
        if (window.showSaveFilePicker) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: "photo.jpg",
              types: [
                {
                  description: "JPEG Image",
                  accept: { "image/jpeg": [".jpg", ".jpeg"] },
                },
              ],
            });
            const writable = await handle.createWritable();
            const response = await fetch(dataUrl);
            await writable.write(await response.blob());
            await writable.close();
            showMessage("Photo saved to device storage.");
            return true;
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error(error);
              // Don't show error for user cancellation, just return false
              return false;
            }
            return false;
          }
        }
        
        // No save method available
        return false;
      }

      async function capturePhoto() {
        if (!preview.srcObject) {
          return;
        }
        const trackSettings = preview.srcObject
          .getVideoTracks()[0]
          ?.getSettings();
        const width = preview.videoWidth || trackSettings?.width || 1280;
        const height = preview.videoHeight || trackSettings?.height || 720;

        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(preview, 0, 0, width, height);

        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        photo.src = dataUrl;
        photo.hidden = false;

        downloadLink.href = dataUrl;
        downloadLink.hidden = false;
        photoActions.hidden = false;
        sharePhotoBtn.hidden = false;
        savePhotoBtn.hidden = false;
        
        // Automatically save the photo
        showMessage("Saving photo...");
        const saved = await savePhotoAutomatically(dataUrl);
        if (!saved) {
          showMessage("Photo captured. You can download it below.");
        }
      }

      function showMessage(message) {
        if (!message) {
          qrResult.style.display = "none";
          qrResult.textContent = "";
          qrResult.classList.remove("error");
          setTimeout(adjustVideoHeight, 50);
          return;
        }
        // Only set textContent if it's a plain string, preserve HTML if already set
        if (typeof message === "string" && !qrResult.querySelector("a") && !qrResult.querySelector("button")) {
          qrResult.textContent = message;
        }
        qrResult.classList.remove("error");
        qrResult.style.display = "block";
        setTimeout(adjustVideoHeight, 50);
      }

      function showError(message) {
        qrResult.textContent = message;
        qrResult.classList.add("error");
        qrResult.style.display = "block";
        setTimeout(adjustVideoHeight, 50);
      }

      function stopScanning() {
        isScanning = false;
        scanBtn.textContent = "Start QR Scan";
        if (scanHandle) {
          cancelAnimationFrame(scanHandle);
          scanHandle = undefined;
        }
        clearQROverlay();
        if (qrOverlay) {
          qrOverlay.style.display = "none";
        }
      }

      function clearQROverlay() {
        if (!qrOverlay) return;
        try {
          const ctx = qrOverlay.getContext("2d");
          if (qrOverlay.width && qrOverlay.height) {
            ctx.clearRect(0, 0, qrOverlay.width, qrOverlay.height);
          }
        } catch (e) {
          console.warn("Could not clear QR overlay:", e);
        }
      }

      function drawQRRectangle(barcode, color = "#9e9e9e") {
        if (!barcode || !barcode.boundingBox || !qrOverlay || !preview) {
          return;
        }

        try {
          const ctx = qrOverlay.getContext("2d");
          const videoRect = preview.getBoundingClientRect();
          const overlayRect = qrOverlay.getBoundingClientRect();
          
          // Get video dimensions
          const videoWidth = preview.videoWidth;
          const videoHeight = preview.videoHeight;
          
          if (!videoWidth || !videoHeight) {
            return; // Video not ready yet
          }
          
          // Get overlay dimensions
          qrOverlay.width = overlayRect.width;
          qrOverlay.height = overlayRect.height;
          
          // Calculate scale factors
          const scaleX = overlayRect.width / videoWidth;
          const scaleY = overlayRect.height / videoHeight;
          
          // Get bounding box coordinates
          const box = barcode.boundingBox;
          const x = box.x * scaleX;
          const y = box.y * scaleY;
          const width = box.width * scaleX;
          const height = box.height * scaleY;
          
          // Clear previous drawing
          ctx.clearRect(0, 0, qrOverlay.width, qrOverlay.height);
          
          // Draw rectangle
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, width, height);
          
          // Draw corner markers for better visibility
          const cornerLength = 20;
          ctx.beginPath();
          // Top-left
          ctx.moveTo(x, y + cornerLength);
          ctx.lineTo(x, y);
          ctx.lineTo(x + cornerLength, y);
          // Top-right
          ctx.moveTo(x + width - cornerLength, y);
          ctx.lineTo(x + width, y);
          ctx.lineTo(x + width, y + cornerLength);
          // Bottom-right
          ctx.moveTo(x + width, y + height - cornerLength);
          ctx.lineTo(x + width, y + height);
          ctx.lineTo(x + width - cornerLength, y + height);
          // Bottom-left
          ctx.moveTo(x + cornerLength, y + height);
          ctx.lineTo(x, y + height);
          ctx.lineTo(x, y + height - cornerLength);
          ctx.stroke();
        } catch (e) {
          console.warn("Could not draw QR rectangle:", e);
        }
      }

      function drawNeutralRectangle() {
        if (!qrOverlay) return;
        try {
          const ctx = qrOverlay.getContext("2d");
          const overlayRect = qrOverlay.getBoundingClientRect();
        
        qrOverlay.width = overlayRect.width;
        qrOverlay.height = overlayRect.height;
        
        // Draw a rectangle in the center
        const centerX = overlayRect.width / 2;
        const centerY = overlayRect.height / 2;
        const rectWidth = overlayRect.width * 0.6;
        const rectHeight = overlayRect.height * 0.4;
        const x = centerX - rectWidth / 2;
        const y = centerY - rectHeight / 2;
        
        ctx.clearRect(0, 0, qrOverlay.width, qrOverlay.height);
        ctx.strokeStyle = "#9e9e9e";
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, rectWidth, rectHeight);
        
        // Draw corner markers
        const cornerLength = 15;
        ctx.beginPath();
        // Top-left
        ctx.moveTo(x, y + cornerLength);
        ctx.lineTo(x, y);
        ctx.lineTo(x + cornerLength, y);
        // Top-right
        ctx.moveTo(x + rectWidth - cornerLength, y);
        ctx.lineTo(x + rectWidth, y);
        ctx.lineTo(x + rectWidth, y + cornerLength);
        // Bottom-right
        ctx.moveTo(x + rectWidth, y + rectHeight - cornerLength);
        ctx.lineTo(x + rectWidth, y + rectHeight);
        ctx.lineTo(x + rectWidth - cornerLength, y + rectHeight);
        // Bottom-left
        ctx.moveTo(x + cornerLength, y + rectHeight);
        ctx.lineTo(x, y + rectHeight);
        ctx.lineTo(x, y + rectHeight - cornerLength);
        ctx.stroke();
        } catch (e) {
          console.warn("Could not draw neutral rectangle:", e);
        }
      }

      async function startScanning() {
        // If camera is not running, start it first
        if (!preview.srcObject) {
          showMessage("Starting camera for QR scanning...");
          await initCamera();
          // Wait a bit for camera to be ready
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        if (!preview.srcObject) {
          showError("Camera failed to start. Please try again.");
          return;
        }
        
        if (!("BarcodeDetector" in window)) {
          showError(
            "Barcode Detector API is not available in this browser. Try the latest Chrome."
          );
          return;
        }

        if (!barcodeDetector) {
          try {
            barcodeDetector = new BarcodeDetector({ formats: ["qr_code"] });
          } catch (error) {
            console.error(error);
            showError("Failed to initialize the barcode detector.");
            return;
          }
        }

        isScanning = true;
        scanBtn.textContent = "Stop QR Scan";
        // Show overlay and draw neutral rectangle in center when starting to scan
        qrOverlay.style.display = "block";
        drawNeutralRectangle();
        scanLoop();
      }

      function isURL(str) {
        try {
          const url = new URL(str);
          return url.protocol === "http:" || url.protocol === "https:";
        } catch {
          return false;
        }
      }

      function handleQRCodeResult(value) {
        stopScanning();
        
        // Clear previous content
        qrResult.innerHTML = "";
        qrResult.classList.remove("error");
        qrResult.style.display = "block";
        
        if (isURL(value)) {
          // It's a URL - automatically open it
          const messageDiv = document.createElement("div");
          messageDiv.textContent = `QR Code detected: ${value}`;
          messageDiv.style.marginBottom = "0.75rem";
          qrResult.appendChild(messageDiv);
          
          // Automatically open the URL
          showMessage(`Opening: ${value}`);
          setTimeout(() => {
            window.open(value, "_blank", "noopener,noreferrer");
          }, 500); // Small delay to show the message
          
          // Add share and copy buttons
          const buttonContainer = document.createElement("div");
          buttonContainer.style.cssText = "display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;";
          
          const shareBtn = document.createElement("button");
          shareBtn.textContent = "Share";
          shareBtn.style.cssText = "padding: 0.75rem 1.25rem; background: #0a84ff; color: white; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer;";
          shareBtn.onclick = () => shareText(value);
          buttonContainer.appendChild(shareBtn);
          
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "Copy";
          copyBtn.style.cssText = "padding: 0.75rem 1.25rem; background: #e5e5ea; color: #1d1d1f; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer;";
          copyBtn.onclick = () => {
            navigator.clipboard.writeText(value).then(() => {
              copyBtn.textContent = "Copied!";
              setTimeout(() => copyBtn.textContent = "Copy", 2000);
            }).catch(() => {
              // Fallback for older browsers
              const textArea = document.createElement("textarea");
              textArea.value = value;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand("copy");
              document.body.removeChild(textArea);
              copyBtn.textContent = "Copied!";
              setTimeout(() => copyBtn.textContent = "Copy", 2000);
            });
          };
          buttonContainer.appendChild(copyBtn);
          qrResult.appendChild(buttonContainer);
        } else {
          // Not a URL - just show the value with copy option
          const messageDiv = document.createElement("div");
          messageDiv.textContent = `QR Code: ${value}`;
          messageDiv.style.marginBottom = "0.75rem";
          qrResult.appendChild(messageDiv);
          
          // Add share and copy buttons
          const buttonContainer = document.createElement("div");
          buttonContainer.style.cssText = "display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;";
          
          const shareBtn = document.createElement("button");
          shareBtn.textContent = "Share";
          shareBtn.style.cssText = "padding: 0.75rem 1.25rem; background: #0a84ff; color: white; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer;";
          shareBtn.onclick = () => shareText(value);
          buttonContainer.appendChild(shareBtn);
          
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "Copy";
          copyBtn.style.cssText = "padding: 0.75rem 1.25rem; background: #e5e5ea; color: #1d1d1f; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer;";
          copyBtn.onclick = () => {
            navigator.clipboard.writeText(value).then(() => {
              copyBtn.textContent = "Copied!";
              setTimeout(() => copyBtn.textContent = "Copy", 2000);
            }).catch(() => {
              // Fallback for older browsers
              const textArea = document.createElement("textarea");
              textArea.value = value;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand("copy");
              document.body.removeChild(textArea);
              copyBtn.textContent = "Copied!";
              setTimeout(() => copyBtn.textContent = "Copy", 2000);
            });
          };
          buttonContainer.appendChild(copyBtn);
          qrResult.appendChild(buttonContainer);
        }
      }

      async function scanLoop() {
        if (!isScanning || !barcodeDetector) {
          return;
        }
        try {
          const barcodes = await barcodeDetector.detect(preview);
          if (barcodes.length) {
            // Draw green rectangle around detected QR code
            drawQRRectangle(barcodes[0], "#34c759");
            const qrValue = barcodes[0].rawValue;
            handleQRCodeResult(qrValue);
            return;
          } else {
            // Draw neutral rectangle in center while scanning
            drawNeutralRectangle();
            if (!qrResult.classList.contains("error")) {
              showMessage("Scanning for QR codes...");
            }
          }
        } catch (error) {
          console.error(error);
          showError("QR scanning failed. Try restarting the camera.");
          stopScanning();
          return;
        }
        scanHandle = requestAnimationFrame(scanLoop);
      }

      toggleCameraBtn.addEventListener("click", () => {
        if (preview.srcObject) {
          stopCamera();
        } else {
          initCamera();
        }
      });
      
      // Capture button with visual feedback
      captureBtn.addEventListener("mousedown", () => {
        if (!captureBtn.disabled) {
          captureBtn.classList.add("pressed");
        }
      });
      captureBtn.addEventListener("mouseup", () => {
        captureBtn.classList.remove("pressed");
      });
      captureBtn.addEventListener("mouseleave", () => {
        captureBtn.classList.remove("pressed");
      });
      captureBtn.addEventListener("touchstart", () => {
        if (!captureBtn.disabled) {
          captureBtn.classList.add("pressed");
        }
      });
      captureBtn.addEventListener("touchend", () => {
        captureBtn.classList.remove("pressed");
      });
      captureBtn.addEventListener("click", () => {
        captureBtn.classList.remove("pressed");
        capturePhoto();
      });

      // Share photo functionality
      async function sharePhoto(dataUrl) {
        // Check if Android interface is available (WebView)
        if (window.AndroidFileSaver && window.AndroidFileSaver.sharePhoto) {
          try {
            const result = window.AndroidFileSaver.sharePhoto(dataUrl);
            showMessage(result);
          } catch (error) {
            console.error(error);
            showError("Failed to share photo: " + error.message);
          }
        } else if (navigator.share) {
          // Use Web Share API if available
          try {
            const response = await fetch(dataUrl);
            const blob = await response.blob();
            const file = new File([blob], "photo.jpg", { type: "image/jpeg" });
            await navigator.share({
              files: [file],
              title: "Shared Photo",
            });
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error(error);
              showError("Failed to share photo: " + error.message);
            }
          }
        } else {
          showError("Sharing is not available in this browser.");
        }
      }

      // Share text functionality
      async function shareText(text) {
        // Check if Android interface is available (WebView)
        if (window.AndroidFileSaver && window.AndroidFileSaver.shareText) {
          try {
            const result = window.AndroidFileSaver.shareText(text);
            showMessage(result);
          } catch (error) {
            console.error(error);
            showError("Failed to share: " + error.message);
          }
        } else if (navigator.share) {
          // Use Web Share API if available
          try {
            await navigator.share({
              text: text,
            });
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error(error);
              showError("Failed to share: " + error.message);
            }
          }
        } else {
          showError("Sharing is not available in this browser.");
        }
      }

      sharePhotoBtn.addEventListener("click", async () => {
        if (photo.src) {
          await sharePhoto(photo.src);
        }
      });

      savePhotoBtn.addEventListener("click", () => {
        if (!photo.src) {
          return;
        }
        
        // Delete the last photo from storage
        if (window.AndroidFileSaver) {
          try {
            const result = window.AndroidFileSaver.deleteLastPhoto();
            if (result.includes("successfully")) {
              // Clear UI
              photo.src = "";
              photo.hidden = true;
              canvas.hidden = true;
              downloadLink.href = "";
              downloadLink.hidden = true;
              photoActions.hidden = true;
              sharePhotoBtn.hidden = true;
              savePhotoBtn.hidden = true;
              showMessage(result);
            } else {
              showError(result);
            }
          } catch (error) {
            console.error(error);
            showError("Failed to delete photo: " + error.message);
          }
        } else {
          // Not in WebView, just clear UI
          photo.src = "";
          photo.hidden = true;
          canvas.hidden = true;
          downloadLink.href = "";
          downloadLink.hidden = true;
          photoActions.hidden = true;
          sharePhotoBtn.hidden = true;
          savePhotoBtn.hidden = true;
          showMessage("Photo removed from display (file deletion not available in browser).");
        }
        
        // Clear message after a short delay
        setTimeout(() => {
          showMessage("");
        }, 3000);
      });
      scanBtn.addEventListener("click", async () => {
        if (isScanning) {
          showMessage("");
          stopScanning();
        } else {
          await startScanning();
        }
      });

      window.addEventListener("beforeunload", stopCamera);

      // Check protocol on page load
      const protocol = window.location.protocol;
      const hostname = window.location.hostname;
      const href = window.location.href;
      const isWebView = /Android/i.test(navigator.userAgent) && 
                       (href.includes('android_asset') || href.includes('file:///android_asset'));
      
      if (!isWebView) {
        if (protocol === "file:" || protocol === "content:") {
          setTimeout(() => {
            showError(
              "⚠️ This page is opened from a file. Camera permissions may not work on Android. " +
              "For best results, host this page on a website (HTTPS) or use a local server. " +
              "Alternatively, go to Chrome Settings → Site Settings → Camera and reset permissions."
            );
          }, 500);
        } else if (protocol === "http:" && hostname !== "localhost" && hostname !== "127.0.0.1" && !hostname.startsWith("192.168.") && !hostname.startsWith("10.")) {
          setTimeout(() => {
            showError(
              "⚠️ Camera access requires HTTPS. Chrome/Brave block camera on HTTP websites. " +
              "Please use HTTPS or localhost (http://localhost works)."
            );
          }, 500);
        }
      }

      // Automatically start camera when page loads (especially in WebView/Android app)
      if (isWebView) {
        // In Android app, start camera automatically after a short delay
        setTimeout(() => {
          initCamera();
        }, 500);
      }
    </script>
  </body>
</html>

